if(all(ind <= setup$N0) || all(ind > setup$N0)) { NA }
else {
weights.boot = weights
weights.boot$omega = sum_normalize(weights$omega[sort(ind[ind <= setup$N0])])
do.call(synthdid_estimate, c(list(Y=setup$Y[sort(ind),], N0=sum(ind <= setup$N0), T0=setup$T0, X=setup$X[sort(ind), ,], weights=weights.boot), opts))
}
}
bootstrap.estimates = rep(NA, replications)
count = 0
while(count < replications) {
bootstrap.estimates[count+1] = theta(sample(1:nrow(setup$Y), replace=TRUE))
if(!is.na(bootstrap.estimates[count+1])) { count = count+1 }
}
bootstrap.estimates
}
View(bootstrap_se)
View(bootstrap_sample)
# Initialize an empty list to store point estimates and statistics
point_estimate_list <- list()
# Loop over each dataframe in result_list
for (state_name in names(result_list)) {
# Access the dataframe
current_df <- result_list[[state_name]]
# Convert to dataframe and clean data
current_df <- as.data.frame(current_df)
current_df <- na.omit(current_df[, c("State_Acronym", "year", "real_ci_cap", "Post")])
# Eliminate states with Inf values
states_with_inf <- current_df %>%
group_by(State_Acronym) %>%
filter(any(is.infinite(real_ci_cap))) %>%
pull(State_Acronym) %>%
unique()
current_df <- current_df %>% filter(!State_Acronym %in% states_with_inf)
# Create the panel matrices for sDiD using synthdid
current_sDiD <- panel.matrices(current_df, unit = "State_Acronym", time = "year", outcome = "real_ci_cap", treatment = "Post")
# Calculate the synthetic difference-in-differences estimate
current_tau_hat <- synthdid_estimate(current_sDiD$Y, current_sDiD$N0, current_sDiD$T0)
# Try calculating the standard error using the bootstrap method with 500 replications
se <- sqrt(vcov(current_tau_hat, method = 'bootstrap', replications = 500))
# Check if the bootstrap method failed (if se is NA)
if (is.na(se)) {
# Print a message indicating the failure of the bootstrap method
cat(sprintf('State: %s - Bootstrap method failed. Switching to placebo method.\n', state_name))
# Fallback to the placebo method for standard error calculation
se <- sqrt(vcov(current_tau_hat, method = 'placebo'))
}
# Calculate the t-statistic and p-value
t_statistic <- as.numeric(current_tau_hat) / se
p_value <- 2 * pt(abs(t_statistic), df = nrow(current_df) - 1, lower.tail = FALSE)
# Print the results
cat(sprintf('State: %s\n', state_name))
cat(sprintf('Point estimate: %1.2f\n', current_tau_hat))
cat(sprintf('95%% CI (%1.2f, %1.2f)\n', current_tau_hat - 1.96 * se, current_tau_hat + 1.96 * se))
cat(sprintf('t-statistic: %1.3f\n', t_statistic))
cat(sprintf('p-value: %1.4f\n', p_value))
}
result <- vcov(current_tau_hat, method = "bootstrap", replications = 500)
print(result)
methods(vcov)
result <- tryCatch({
vcov.synthdid_estimate(current_tau_hat, method = "bootstrap", replications = 500)
}, error = function(e) {
cat(sprintf('Bootstrap method failed. Error: %s\n', e$message))
NA  # Return NA if there's an error
})
View(result)
print(result())
current_sDiD <- panel.matrices(current_df, unit = "State_Acronym", time = "year", outcome = "real_ci_cap", treatment = "Post")
View(current_sDiD)
current_tau_hat <- synthdid_estimate(current_sDiD$Y, current_sDiD$N0, current_sDiD$T0)
result <- tryCatch({
se <- sqrt(vcov(current_tau_hat, method = "bootstrap", replications = 500))
print(se)  # If successful, print the SE
se  # Return the SE for further calculations
}, error = function(e) {
cat(sprintf('Bootstrap method failed. Error: %s\n', e$message))
NA  # Return NA if bootstrap fails
})
# Define the custom vcov function for synthdid_estimate
vcov.synthdid_estimate <- function(object, method = c("bootstrap", "jackknife", "placebo"), replications = 500, ...) {
method = match.arg(method)
if(method == 'bootstrap') {
se = bootstrap_se(object, replications)
} else if(method == 'jackknife') {
se = jackknife_se(object)
} else if(method == 'placebo') {
se = placebo_se(object, replications)
}
matrix(se^2)
}
methods(vcov)
str(current_tau_hat)
test_se <- tryCatch({
bootstrap_se(current_tau_hat, replications = 500)
}, error = function(e) {
cat(sprintf('Bootstrap SE calculation failed. Error: %s\n', e$message))
NA
})
print(test_se)
result <- tryCatch({
se <- sqrt(vcov(current_tau_hat, method = "bootstrap", replications = 500))
print(se)  # If successful, print the SE
se  # Return the SE for further calculations
}, error = function(e) {
cat(sprintf('Bootstrap method failed. Error: %s\n', e$message))
NA  # Return NA if bootstrap fails
})
# Print the result
print(result)
test_vcov <- vcov(current_tau_hat, method = "bootstrap", replications = 500)
print(test_vcov)
example_Y <- matrix(c(1, 2, 3, 4, 5), nrow=5)
example_N0 <- 2
example_T0 <- 3
example_estimate <- synthdid_estimate(example_Y, example_N0, example_T0)
# Check if vcov works with this example
example_vcov <- tryCatch({
vcov(example_estimate, method = "bootstrap", replications = 10)
}, error = function(e) {
cat(sprintf('Error: %s\n', e$message))
NA
})
# Create example data
example_Y <- matrix(c(
1, 2, 3, 4, 5, 6,
2, 3, 4, 5, 6, 7,
3, 4, 5, 6, 7, 8,
4, 5, 6, 7, 8, 9,
5, 6, 7, 8, 9, 10
), nrow=5)
example_N0 <- 5  # Number of control units
example_T0 <- 3  # Number of treatment periods
# Estimate using synthdid
library(synthdid)  # Make sure the synthdid package is loaded
example_estimate <- tryCatch({
synthdid_estimate(example_Y, example_N0, example_T0)
}, error = function(e) {
cat(sprintf('Error in synthdid_estimate: %s\n', e$message))
NA
})
# Check vcov with the example estimate
if (!is.na(example_estimate)) {
example_vcov <- tryCatch({
vcov(example_estimate, method = "bootstrap", replications = 10)
}, error = function(e) {
cat(sprintf('Error: %s\n', e$message))
NA
})
print(example_vcov)
}
# Create example data
example_Y <- matrix(c(
1, 2, 3, 4, 5, 6,
2, 3, 4, 5, 6, 7,
3, 4, 5, 6, 7, 8,
4, 5, 6, 7, 8, 9,
5, 6, 7, 8, 9, 10,
6, 7, 8, 9, 10, 11  # Adding more rows
), nrow=6)  # Increase rows
example_N0 <- 5  # Number of control units
example_T0 <- 3  # Number of treatment periods
# Estimate using synthdid
library(synthdid)  # Make sure the synthdid package is loaded
example_estimate <- tryCatch({
synthdid_estimate(example_Y, example_N0, example_T0)
}, error = function(e) {
cat(sprintf('Error in synthdid_estimate: %s\n', e$message))
NA
})
# Check vcov with the example estimate
if (!is.na(example_estimate)) {
example_vcov <- tryCatch({
vcov(example_estimate, method = "bootstrap", replications = 10)
}, error = function(e) {
cat(sprintf('Error: %s\n', e$message))
NA
})
print(example_vcov)
}
#Run a one-sided Significance test
#Load Packages
library(tidyr)
library(dplyr)
library(tidyverse)
library(lmtest)
library(ggplot2)
library(did) # for running DiD
library(plm)
library(lmtest)
library(synthdid)
library(fixest)
library(boot)
library(ggthemes)
# set seed
set.seed(26)
#JMP Directory
setwd("~/Documents/GitHub/ST-Apportionment/job_market_data")
#Load Detrended, per capita, real revenue data
Rev <- read.csv("detrend_per_capita.csv")
Corp <-read.csv("CIT_sDID_loop.csv")
naive_ci<-read.csv("naive_ci.csv")
View(naive_ci)
real_CI <- naive_ci%>%
mutate(real_ci = (naive_ci/CPI_def)*100)
real_CI_cap <- real_CI %>%
mutate(real_ci_cap = real_ci/population)
Filter_frac <-real_CI_cap %>%
select(State_Acronym,year,year_effective,State_Name,real_ci_cap,Post)
filt_Corp <-Filter_frac
#Create State Dataframes
#create result list to store dataframe
result_list <- list()
# Make a copy of the original dataframe to work with
original_df <- filt_Corp
#counter variable, so as loop progresses, drops first state
counter <- 1
while (TRUE) {
#Reset to original each start
df <-filt_Corp
# Arrange by year_effective and select the first state for treatment
df <- df %>% arrange(year_effective)
#counter variable for running the loop
if(df$year_effective[counter] >= 2022) {break}
treatment_state <- df %>% slice(counter)
treatment_year <- treatment_state$year_effective
treatment_state_name <- treatment_state$State_Name
#filter out prior treated states, but keep no treatment states
#first half of filter keeps no treatment states in,
df <- df %>%
filter(is.na(year_effective) | is.na(State_Acronym) | year_effective >= treatment_year)
# removes states treated in same year
#the year_effective=treatment_year are filtered out if they are not 'treatment_state'
df <- df %>%
filter(is.na(year_effective) | (!(State_Name != treatment_state_name & year_effective == treatment_year)))
# Filter out rows with year <= 2 years after treatment_year
df <- df %>%
filter(year <= treatment_year + 2)
#filter out any states that get treated within 2 years of treatment
df <- df %>%
filter(is.na(year_effective) | (!(year_effective > treatment_year & year_effective<= treatment_year + 2)))
#filter out Ohio after treatment_year >=2012, because OH eliminates CI in 2014
df <- df %>%
filter(!(treatment_year >= 2012 & State_Name == "Ohio"))
# Store the dataframe for this treatment state
assign(treatment_state_name, df)
result_list[[treatment_state_name]] <- df
# Check if the treatment year is 2022 or greater, break
if (treatment_year >= 2022) {break}
#increment counter
counter <-counter + 1
#empty dataframe break
if (nrow(df) == 0) {break}
}
View(Alabama)
# Initialize an empty list to store point estimates and statistics
point_estimate_list <- list()
View(result_list)
# Loop over each dataframe in result_list
for (state_name in names(result_list)) {
# Access the dataframe
current_df <- result_list[[state_name]]
#Make the tibble from the result list a dataframe, easier for panel.matrics function
current_df <- as.data.frame(current_df)
#Drop states that have NA for ratio (like Alaska because no Income Tax)
current_df <- na.omit(current_df[, c("State_Acronym", "year", "real_ci_cap", "Post")])
#eliminate Inf lines and the state that has them for estimation, like Ohio 2009-2013
states_with_inf <- current_df %>%
group_by(State_Acronym) %>%
filter(any(is.infinite(real_ci_cap))) %>%
pull(State_Acronym) %>%
unique()
# Filter out those states from the dataframe
current_df <- current_df %>%
filter(!State_Acronym %in% states_with_inf)
# Create the panel matrices for sDiD using synthdid
current_sDiD <- panel.matrices(current_df, unit = "State_Acronym", time = "year", outcome = "real_ci_cap", treatment = "Post")
# Calculate the synthetic difference-in-differences estimate
current_tau_hat <- synthdid_estimate(current_sDiD$Y, current_sDiD$N0, current_sDiD$T0)
se <- sqrt(vcov(current_tau_hat, method = 'placebo'))
#Have a point estimate impact on Real CI per capita
# Calculate the t-statistic
t_statistic <- as.numeric(current_tau_hat) / se
# Calculate the p-value
p_value <- 2 * pt(abs(t_statistic), df = nrow(current_df) - 1, lower.tail = FALSE)
# Print the point estimate, confidence interval, t-statistic, and p-value
cat(sprintf('State: %s\n', state_name))
cat(sprintf('Point estimate: %1.2f\n', current_tau_hat))
cat(sprintf('95%% CI (%1.2f, %1.2f)\n', current_tau_hat - 1.96 * se, current_tau_hat + 1.96 * se))
cat(sprintf('t-statistic: %1.3f\n', t_statistic))
cat(sprintf('p-value: %1.4f\n', p_value))
# Summary statistics
#  print(summary(current_tau_hat))
}
vcov.synthdid_estimate <- function(object, method = c("bootstrap", "jackknife", "placebo"), replications = 500, ...) {
method = match.arg(method)
if(method == 'bootstrap') {
se = bootstrap_se(object, replications)
} else if(method == 'jackknife') {
se = jackknife_se(object)
} else if(method == 'placebo') {
se = placebo_se(object, replications)
}
matrix(se^2)
}
#' @param ... Any valid arguments for vcov.synthdid_estimate
#' @export synthdid_se
@export synthdid_se
n <-500
replications <-500
estimate <-current_tau_hat
setup<- current_sDiD
# The bootstrap se: Algorithm 2 of Arkhangelsky et al.
bootstrap_se = function(estimate, replications) { sqrt((replications-1)/replications) * sd(bootstrap_sample(estimate, replications)) }
View(bootstrap_se)
bootstrap_sample = function(estimate, replications) {
setup = attr(estimate, 'setup')
opts = attr(estimate, 'opts')
weights = attr(estimate, 'weights')
if (setup$N0 == nrow(setup$Y) - 1) { return(NA) }
theta = function(ind) {
if(all(ind <= setup$N0) || all(ind > setup$N0)) { NA }
else {
weights.boot = weights
weights.boot$omega = sum_normalize(weights$omega[sort(ind[ind <= setup$N0])])
do.call(synthdid_estimate, c(list(Y=setup$Y[sort(ind),], N0=sum(ind <= setup$N0), T0=setup$T0, X=setup$X[sort(ind), ,], weights=weights.boot), opts))
}
}
bootstrap.estimates = rep(NA, replications)
count = 0
while(count < replications) {
bootstrap.estimates[count+1] = theta(sample(1:nrow(setup$Y), replace=TRUE))
if(!is.na(bootstrap.estimates[count+1])) { count = count+1 }
}
bootstrap.estimates
}
View(bootstrap_sample)
#' @references Dmitry Arkhangelsky, Susan Athey, David A. Hirshberg, Guido W. Imbens, and Stefan Wager.
#'  "Synthetic Difference in Differences". arXiv preprint arXiv:1812.09970, 2019.
#'
#' @method vcov synthdid_estimate
#' @export
# Define the custom vcov function for synthdid_estimate
vcov.synthdid_estimate <- function(object, method = c("bootstrap", "jackknife", "placebo"), replications = 500, ...) {
method = match.arg(method)
if(method == 'bootstrap') {
se = bootstrap_se(object, replications)
} else if(method == 'jackknife') {
se = jackknife_se(object)
} else if(method == 'placebo') {
se = placebo_se(object, replications)
}
matrix(se^2)
}
#' Calculate the standard error of a synthetic diff in diff estimate. Deprecated. Use vcov.synthdid_estimate.
#' @param ... Any valid arguments for vcov.synthdid_estimate
# @export synthdid_se
synthdid_se = function(current_tau_hat,) { sqrt(vcov(...)) }
#'  data sets, the jackknife option is the fastest, with the caveat that it is not recommended
#'  for SC).
#' @param replications, the number of bootstrap replications
#' @param ... Additional arguments (currently ignored).
#'
#' @references Dmitry Arkhangelsky, Susan Athey, David A. Hirshberg, Guido W. Imbens, and Stefan Wager.
#'  "Synthetic Difference in Differences". arXiv preprint arXiv:1812.09970, 2019.
#'
#' @method vcov synthdid_estimate
#' @export
vcov.synthdid_estimate = function(object,
method = c("bootstrap", "jackknife", "placebo"),
replications = 200, ...) {
method = match.arg(method)
if(method == 'bootstrap') {
se = bootstrap_se(object, replications)
} else if(method == 'jackknife') {
se = jackknife_se(object)
} else if(method == 'placebo') {
se = placebo_se(object, replications)
}
matrix(se^2)
}
#' Calculate the standard error of a synthetic diff in diff estimate. Deprecated. Use vcov.synthdid_estimate.
#' @param ... Any valid arguments for vcov.synthdid_estimate
#' @export synthdid_se
synthdid_se = function(...) { sqrt(vcov(...)) }
# The bootstrap se: Algorithm 2 of Arkhangelsky et al.
bootstrap_se = function(estimate, replications) { sqrt((replications-1)/replications) * sd(bootstrap_sample(estimate, replications)) }
bootstrap_sample = function(estimate, replications) {
setup = attr(estimate, 'setup')
opts = attr(estimate, 'opts')
weights = attr(estimate, 'weights')
if (setup$N0 == nrow(setup$Y) - 1) { return(NA) }
theta = function(ind) {
if(all(ind <= setup$N0) || all(ind > setup$N0)) { NA }
else {
weights.boot = weights
weights.boot$omega = sum_normalize(weights$omega[sort(ind[ind <= setup$N0])])
do.call(synthdid_estimate, c(list(Y=setup$Y[sort(ind),], N0=sum(ind <= setup$N0), T0=setup$T0, X=setup$X[sort(ind), ,], weights=weights.boot), opts))
}
}
bootstrap.estimates = rep(NA, replications)
count = 0
while(count < replications) {
bootstrap.estimates[count+1] = theta(sample(1:nrow(setup$Y), replace=TRUE))
if(!is.na(bootstrap.estimates[count+1])) { count = count+1 }
}
bootstrap.estimates
}
# The fixed-weights jackknife estimate of variance: Algorithm 3 of Arkhangelsky et al.
# if weights = NULL is passed explicitly, calculates the usual jackknife estimate of variance.
# returns NA if there is one treated unit or, for the fixed-weights jackknife, one control with nonzero weight
jackknife_se = function(estimate, weights = attr(estimate, 'weights')) {
setup = attr(estimate, 'setup')
opts = attr(estimate, 'opts')
if (!is.null(weights)) {
opts$update.omega = opts$update.lambda = FALSE
}
if (setup$N0 == nrow(setup$Y) - 1 || (!is.null(weights) && sum(weights$omega != 0) == 1)) { return(NA) }
theta = function(ind) {
weights.jk = weights
if (!is.null(weights)) { weights.jk$omega = sum_normalize(weights$omega[ind[ind <= setup$N0]]) }
estimate.jk = do.call(synthdid_estimate,
c(list(Y=setup$Y[ind, ], N0=sum(ind <= setup$N0), T0=setup$T0, X = setup$X[ind, , ], weights = weights.jk), opts))
}
jackknife(1:nrow(setup$Y), theta)
}
#' Jackknife standard error of function `theta` at samples `x`.
#' @param x vector of samples
#' @param theta a function which returns a scalar estimate
#' @importFrom stats var
#' @keywords internal
jackknife = function(x, theta) {
n = length(x)
u = rep(0, n)
for (i in 1:n) {
u[i] = theta(x[-i])
}
jack.se = sqrt(((n - 1) / n) * (n - 1) * var(u))
jack.se
}
# The placebo se: Algorithm 4 of Arkhangelsky et al.
placebo_se = function(estimate, replications) {
setup = attr(estimate, 'setup')
opts = attr(estimate, 'opts')
weights = attr(estimate, 'weights')
N1 = nrow(setup$Y) - setup$N0
if (setup$N0 <= N1) { stop('must have more controls than treated units to use the placebo se') }
theta = function(ind) {
N0 = length(ind)-N1
weights.boot = weights
weights.boot$omega = sum_normalize(weights$omega[ind[1:N0]])
do.call(synthdid_estimate, c(list(Y=setup$Y[ind,], N0=N0,  T0=setup$T0,  X=setup$X[ind, ,], weights=weights.boot), opts))
}
sqrt((replications-1)/replications) * sd(replicate(replications, theta(sample(1:setup$N0))))
}
sum_normalize = function(x) {
if(sum(x) != 0) { x / sum(x) }
else { rep(1/length(x), length(x)) }
# if given a vector of zeros, return uniform weights
# this fine when used in bootstrap and placebo standard errors, where it is used only for initialization
# for jackknife standard errors, where it isn't, we handle the case of a vector of zeros without calling this function.
}
vcov.synthdid_estimate(current_tau_hat,method = 'bootstrap',replications = 500)
View(vcov.synthdid_estimate)
# set seed
set.seed(26)
#JMP Directory
setwd("~/Documents/GitHub/ST-Apportionment/job_market_data")
View(current_df)
View(current_sDiD)
current_sDiD[["T0"]]
current_sDiD[["T0"]]
View(current_df)
# Calculate the synthetic difference-in-differences estimate
current_tau_hat <- synthdid_estimate(current_sDiD$Y, current_sDiD$N0, current_sDiD$T0)
# Create the panel matrices for sDiD using synthdid
current_sDiD <- panel.matrices(current_df, unit = "State_Acronym", time = "year", outcome = "real_ci_cap", treatment = "Post")
current_sDiD
# Calculate the synthetic difference-in-differences estimate
current_tau_hat <- synthdid_estimate(current_sDiD$Y, current_sDiD$N0, current_sDiD$T0)
current_tau_hat
vcov.synthdid_estimate(current_sDiD,method = 'bootstrap', replications = 500)
View(jackknife)
View(current_df)
View(current_df)
View(current_sDiD)
View(current_sDiD)
# Fit the synthdid model using current_sDiD
estimate <- synthdid_estimate(Y = current_sDiD$Y, N0 = current_sDiD$N0, T0 = current_sDiD$T0, X = NULL, weights = current_sDiD$weights)
# Fit the synthdid model using current_sDiD
estimate <- synthdid_estimate(Y = current_sDiD$Y, N0 = current_sDiD$N0, T0 = current_sDiD$T0, weights = current_sDiD$weights)
# Fit the synthdid model using current_sDiD
estimate <- synthdid_estimate(Y = current_sDiD$Y, N0 = current_sDiD$N0, T0 = current_sDiD$T0)
# Calculate the variance-covariance matrix using the bootstrap method
vcov_result <- vcov.synthdid_estimate(estimate, method = "bootstrap", replications = 500)
# Calculate standard errors
se_result <- synthdid_se(estimate, method = "bootstrap", replications = 500)
# View results
print(vcov_result)
print(se_result)
print(estimate)
summary(current_sDiD$Y)
vcov_bootstrap <- vcov(estimate, method = "bootstrap", replications = 500)
# Calculate standard errors by taking the square root of the diagonal of the variance-covariance matrix
se_result_bootstrap <- sqrt(diag(vcov_bootstrap))
# View the results
print(se_result_bootstrap)
print(estimate)
dim(current_sDiD$Y)
summary(current_sDiD$Y)
vcov_bootstrap <- vcov(estimate, method = "bootstrap", replications = 50)
se_result_bootstrap <- sqrt(diag(vcov_bootstrap))
print(se_result_bootstrap)
