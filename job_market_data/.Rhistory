#Load Data Tables in R
install.packages("data.table")
# Get rate of change for tax bases and find elasticity of tax base w.r.t apportionment and rate changes.
#Redo Callaway and Sant'Anna From Summer
library(readxl)
library(tidyr)
library(dplyr)
library(did)
library(tidyverse)
library(lmtest)
library(caret)
library(ggplot2)
#New Directory
setwd("~/Documents/GitHub/ST_Apportionment/Rates_Of_Change")
# Severance Tax- Two Way Fixed Effects
# will need to include all states, even those with ZERO SEVERANCE TAX, following dougan Input
#Load Packages
library(tidyr)
library(dplyr)
library(tidyverse)
library(lmtest)
library(ggplot2)
library(readxl) #load ssfa switch date
library(did) # for running DiD
library(caret)
library(plm) # for Two way FE
library(fixest) # multiple FE
library(broom) #extract coefficients for each state
set.seed(26)
#JMP Directory
setwd("~/Documents/GitHub/ST-Apportionment/job_market_data")
#Now run 2WFE
Sev <-read.csv("Severance_2WFE.csv")
library(readxl)
#Load Files
Pop <-read_excel("State_Resident_Population.xls",sheet=2)
#Clean Up Year for Pop
library(lubridate)
Pop <- mutate(Pop$DATE,year= year(DATE))
#Get abbreviations for states
state_abbreviations <- c("AL", "AK", "AZ", "AR", "CA", "CO", "CT", "DE", "FL", "GA", "HI", "ID", "IL", "IN", "IA", "KS", "KY", "LA", "ME", "MD", "MA", "MI", "MN", "MS", "MO", "MT", "NE", "NV", "NH", "NJ", "NM", "NY", "NC", "ND", "OH", "OK", "OR", "PA", "RI", "SC", "SD", "TN", "TX", "UT", "VT", "VA", "WA", "WV", "WI", "WY")
# Reshape Pop dataframe to long format
Pop_long <- Pop %>% gather(key = "State", value = "population", -DATE)
# Extract year from DATE column in Pop_long dataframe
Pop_long$DATE <- substr(Pop_long$DATE, 1, 4)
# Merge dataframes on 'Year' and 'State' columns
Sev_pop <- merge(Sev, Pop_long, by.x = c("Year", "State"), by.y = c("DATE", "State"), all.x = TRUE)
View(Pop_long)
# Merge dataframes on 'Year' and 'State' columns
Sev_pop <- merge(Sev, Pop_long, by.x = c("year", "state"), by.y = c("DATE", "State"), all.x = TRUE)
View(Sev_pop)
View(Pop_long)
View(Pop)
View(Pop)
#Change full Date to Year
Pop$DATE <- as.Date(Pop$DATE)
transform(Pop, date=format(DATE "%d")),
View(Pop)
#Load Files
Pop <-read_excel("State_Resident_Population.xls",sheet=2)
#Clean Up Year for Pop
library(lubridate)
Pop <- mutate(Pop$DATE,year= year(DATE))
View(Pop)
View(Pop_long)
state <- c("Alaska", "Alabama", "Arkansas", "Arizona", "California", "Colorado",
"Connecticut", "Delaware", "Florida", "Georgia", "Hawaii", "Iowa",
"Idaho", "Illinois", "Indiana", "Kansas", "Kentucky", "Louisiana",
"Massachusetts", "Maryland", "Maine", "Michigan", "Minnesota",
"Missouri", "Mississippi", "Montana", "North Carolina", "North Dakota",
"Nebraska", "New Hampshire", "New Jersey", "New Mexico", "Nevada",
"New York", "Ohio", "Oklahoma", "Oregon", "Pennsylvania", "Rhode Island",
"South Carolina", "South Dakota", "Tennessee", "Texas", "Utah",
"Virginia", "Vermont", "Washington", "Wisconsin", "West Virginia",
"Wyoming")
# Reshape Pop dataframe to long format
Pop_long <- Pop %>% gather(key = "state", value = "population", -DATE)
View(Pop_long)
# Reshape Pop dataframe to long format
Pop_long <- Pop %>% gather(key = "state_abbreviations", value = "population", -DATE)
# Extract year from DATE column in Pop_long dataframe
Pop_long$DATE <- substr(Pop_long$DATE, 1, 4)
View(Pop_long)
View(Pop)
str(Pop_long)
#Need to create an acronym column which consists of first two characters of
#or remove POP from "state_abbreviations" column
Pop_long$state_abbreviations <-sub("POP","",Pop_long$state_abbreviations)
View(Pop_long)
# Merge dataframes on 'Year' and 'State' columns
Sev_pop <- merge(Sev, Pop_long, by.x = c("year", "State_Acronym"), by.y = c("DATE", "state_abbreviation"), all.x = TRUE)
# Merge dataframes on 'Year' and 'State' columns
Sev_pop <- merge(Sev, Pop_long, by.x = c("year", "State_Acronym"), by.y = c("DATE", "state_abbreviations"), all.x = TRUE)
View(Sev_pop)
write.csv(Sev_pop,"Severance_Population.csv")
str(Sev_pop)
# PART II, create Severance Tax per capita, by state
Sev2 <- Sev_pop %>%
mutate(Sev_cap=SVRNCTAX/population)
View(Sev2)
#now, filter for years 1976 through today
Sev3 <- Sev2 %>%
filter(year>=1976)
View(Sev3)
#Replace NAs for per capita revenue with 0
Sev3$Sev_cap[is.na(df$Sev_cap)] <- 0
#Replace NAs for per capita revenue with 0
Sev3$Sev_cap[is.na(df$Sev_cap)] <- 0
#Replace NAs for per capita revenue with 0
Sev3$Sev_cap[is.na(Sev3$Sev_cap)] <- 0
View(Sev3)
#Simple Reg (w/o rate) (a) (i)
Simple_reg <- lm(Sev_cap ~ Post_eff + factor(year) + factor(state), Sev3)
#Simple Reg (w/o rate) (a) (i)
Simple_reg <- lm(Sev_cap ~ post_eff + factor(year) + factor(state), Sev3)
summary(Simple_reg)
#He just wants to see, is there a relationship between severance tax revenue
#treatment.
# I can try and break those coefficients up by state
# Interaction Reg (with interaction between Post and state)
Interaction_reg <- lm(Sev_cap~ post_eff * factor(state) + factor(year), data = Sev3)
summary(Interaction_reg)
# It is close, just trying to get Alabama
# Set Alabama as the reference category
Sev3$state <- relevel(factor(Sev3$state), ref = "Alabama")
# Interaction Reg (with interaction between Post and state)
Interaction_reg2 <- lm(Sev3 ~ post_eff * factor(state) + factor(year), data = Sev3)
# Interaction Reg (with interaction between Post and state)
Interaction_reg2 <- lm(Sev_cap ~ post_eff * factor(state) + factor(year), data = Sev3)
summary(Interaction_reg2)
#Extract coefficients for each state using Broom
tidy_model <- tidy(Interaction_reg2)
# Filter the coefficients to get only those related to Post
post_coefficients <- tidy_model %>%
filter(grepl("post_eff", term))
print(post_coefficients)
fit_state_model <- function(Sev3) {
lm(Sev_cap~ post_eff + factor(year), data = Sev3)
}
# Split data by state and fit model for each state
state_models <- Sev3 %>%
group_by(state) %>%
group_map(~ fit_state_model(.x))
lm(Sev_cap~ post_eff + factor(year), data = df)
#Extracting the post coefficient for each state
fit_state_model <- function(df) {
lm(Sev_cap~ post_eff + factor(year), data = df)
}
# Split data by state and fit model for each state
state_models <- Sev3 %>%
group_by(state) %>%
group_map(~ fit_state_model(.x))
# Remove any NULL models (if any states had insufficient data)
state_models <- state_models[!sapply(state_models, is.null)]
# Split data by state and fit model for each state
state_models <- Sev3 %>%
group_by(state) %>%
group_map(~ fit_state_model(.x))
# Split data by state and fit model for each state
state_models <- Sev3 %>%
group_by(state) %>%
group_map(~ fit_state_model(.x))
#Extracting the post coefficient for each state
fit_state_model <- function(df) {
df <- df %>%
droplevels() %>%
filter(n_distinct(state) > 1, n_distinct(year) > 1) # Ensure factors have >1 level
if(nrow(df) > 0) {
lm(Sev_cap ~ post_eff + factor(year), data = df)
} else {
NULL
}
}
# Split data by state and fit model for each state
state_models <- Sev3 %>%
group_by(state) %>%
group_map(~ fit_state_model(.x))
df <- df %>%
droplevels() %>%
filter(n_distinct(state) > 1, n_distinct(year) > 1) # Ensure factors have >1 level
df <- df %>%
droplevels() %>%
filter(n_distinct(state) > 1, n_distinct(year) > 1) # Ensure factors have >1 level
fit_state_model <- function(df) {
df <- df %>%
droplevels() %>%
filter(n_distinct(state) > 1, n_distinct(year) > 1) # Ensure factors have >1 level
# Diagnostic message
cat("Processing state:", unique(df$state), "\n")
cat("Number of distinct states:", n_distinct(df$state), "\n")
cat("Number of distinct years:", n_distinct(df$year), "\n")
cat("Number of rows:", nrow(df), "\n\n")
# Split data by state and fit model for each state
state_models <- Sev3 %>%
group_by(state) %>%
group_map(~ fit_state_model(.x))
# Remove any NULL models (if any states had insufficient data)
state_models <- state_models[!sapply(state_models, is.null)]
# Extract coefficients for Post from each model
post_coeffs <- lapply(state_models, function(model) {
tidy(model) %>% filter(term == "Post")
})
# Extract coefficients for Post from each model
post_coeffs <- lapply(state_models, function(model) {
tidy(model) %>% filter(term == "post_eff")
})
# Combine results into a single data frame
post_coeffs_df <- bind_rows(post_coeffs, .id = "state")
print(post_coeffs_df)
View(post_coefficients)
View(post_coefficients)
# Define the model function with added checks
fit_state_model <- function(df) {
df <- df %>%
droplevels() %>%
filter(n_distinct(state) > 1, n_distinct(year) > 1) # Ensure factors have >1 level
# Diagnostic message
cat("Processing state:", unique(df$state), "\n")
cat("Number of distinct states:", n_distinct(df$state), "\n")
cat("Number of distinct years:", n_distinct(df$year), "\n")
cat("Number of rows:", nrow(df), "\n\n")
}
# Split data by state and fit model for each state
state_models <- Sev3 %>%
group_by(state) %>%
group_map(~ fit_state_model(.x))
# Remove any NULL models (if any states had insufficient data)
state_models <- state_models[!sapply(state_models, is.null)]
# Extract coefficients for Post from each model
post_coeffs <- lapply(state_models, function(model) {
tidy(model) %>% filter(term == "post_eff")
})
# Combine results into a single data frame
post_coeffs_df <- bind_rows(post_coeffs, .id = "state")
print(post_coeffs_df)
View(post_coefficients)
View(post_coefficients)
print(post_coeffs_df)
#Extracting the post coefficient for each state
# Define the model function with added checks
fit_state_model <- function(df) {
df <- df %>%
droplevels() %>%
filter(n_distinct(state) > 1, n_distinct(year) > 1) # Ensure factors have >1 level
# Diagnostic message
cat("Processing state:", unique(df$state), "\n")
cat("Number of distinct states:", n_distinct(df$state), "\n")
cat("Number of distinct years:", n_distinct(df$year), "\n")
cat("Number of rows:", nrow(df), "\n\n")
}
# Split data by state and fit model for each state
state_models <- Sev3 %>%
group_by(state) %>%
group_map(~ fit_state_model(.x))
# will need to include all states, even those with ZERO SEVERANCE TAX, following dougan Input
#Load Packages
library(tidyr)
library(dplyr)
library(tidyverse)
library(lmtest)
library(ggplot2)
library(readxl) #load ssfa switch date
library(did) # for running DiD
library(caret)
library(plm) # for Two way FE
library(fixest) # multiple FE
library(broom) #extract coefficients for each state
#Extracting the post coefficient for each state
# Define the model function with added checks
fit_state_model <- function(df) {
df <- df %>%
droplevels() %>%
filter(n_distinct(state) > 1, n_distinct(year) > 1) # Ensure factors have >1 level
# Diagnostic message
cat("Processing state:", unique(df$state), "\n")
cat("Number of distinct states:", n_distinct(df$state), "\n")
cat("Number of distinct years:", n_distinct(df$year), "\n")
cat("Number of rows:", nrow(df), "\n\n")
}
# Split data by state and fit model for each state
state_models <- Sev3 %>%
group_by(state) %>%
group_map(~ fit_state_model(.x))
# Remove any NULL models (if any states had insufficient data)
state_models <- state_models[!sapply(state_models, is.null)]
# Extract coefficients for Post from each model
post_coeffs <- lapply(state_models, function(model) {
tidy(model) %>% filter(term == "post_eff")
})
# Combine results into a single data frame
post_coeffs_df <- bind_rows(post_coeffs, .id = "state")
print(post_coeffs_df)
View(post_coefficients)
View(Sev3)
write.csv(Sev3,"Severance_Cap_mutate.csv")
#Just try simple regression
Reg <- lm(Sev_cap ~ sales + factor(year) + factor(state), Sev3)
summary(Reg)
#Replace Sales NA with 0
Sev3$Sev_sales[is.na(Sev3$sales)] <- 0
#Just try simple regression
Reg <- lm(Sev_cap ~ sales + factor(year) + factor(state), Sev3)
summary(Reg)
#interaction between State and Sales Factor Weight
Int_reg <- lm(Sev_cap~ post_eff * factor(state) + factor(year), data = Sev3)
summary(Int_reg)
#Replace Sales NA with 0
Sev3$sales[is.na(Sev3$sales)] <- 0
View(Sev3)
Sev3 %>% select(-Sev_sales)
Sev3 <- Sev3 %>% select(-Sev_sales)
View(Sev3)
Sev3 <- Sev3 %>%
mutate(Sev_log = log(SVRNCTAX))
View(Sev3)
summary(Reg)
#Just try simple regression, Sev per capita
Reg_cap <- lm(Sev_cap ~ sales + factor(year) + factor(state), Sev3)
summary(Reg_cap)
#interaction between State and Sales Factor Weight
Int_reg_cap <- lm(Sev_cap~ sales * factor(state) + factor(year), data = Sev3)
summary(Int_reg_cap)
#WANT SUMMARY STATISTICS ON Sev_cap and Sev_log
Reg_log <- lm(Sev_log ~ sales + factor(year) + factor(state), Sev3)
View(Sev3)
Sev3$Sev_log[is.na(Sev3$Sev_log)] <- 0
View(Sev3)
# Sev log going to 0
Sev3$Sev_log[is.na(Sev3$Sev_log)] <- 0
#WANT SUMMARY STATISTICS ON Sev_cap and Sev_log
Reg_log <- lm(Sev_log ~ sales + factor(year) + factor(state), Sev3)
summary(Sev3$Sev_log)
sum(is.na(Sev3$Sev_log))
sum(is.nan(Sev3$Sev_log))
sum(is.infinite(Sev3$Sev_log))
#WANT SUMMARY STATISTICS ON Sev_cap and Sev_log
summary(Sev3$Sev_cap)
infinite_values_df <- Sev3 %>%
filter(is.infinite(Sev_log))
View(infinite_values_df)
write.csv(infinite_values_df, "No_Sev_revenue.csv")
#Run as Sev 4, removing those values
Sev4 <- Sev3 %>%
filter(!is.infinite(Sev_log))
#Run again
Reg_log <- lm(Sev_log ~ sales + factor(year) + factor(state), Sev4)
summary(Reg_log)
#Going to try this again with just a switch dummy
Sev5 <- Sev4 %>%
group_by(state) %>%
mutate(switch=ifelse(any(post_eff == 1), 1, 0))%>%
ungroup()
View(Sev5)
#Any switch with NA, replace with 0
Sev5$switch[is.na(Sev3$switch)] <- 0
View(Sev5)
View(Sev5)
str(Sev5)
Sev5 <- Sev5 %>%
mutate(switch = ifelse(is.na(switch), 0, switch))
View(Sev5)
#Average Sev_Cap Revenue whether switch or not
avg_Sev_cap_by_switch <- Sev5 %>%
group_by(switch) %>%
summarize(avg_Sev_cap = mean(Sev_cap, na.rm = TRUE))
# View the result
print(avg_Sev_cap_by_switch)
# Get states with switch = 1
states_switch_1 <- Sev5 %>%
filter(switch == 1) %>%
distinct(state) %>%
pull(state)
# Get states with switch = 0
states_switch_0 <- Sev5 %>%
filter(switch == 0) %>%
distinct(state) %>%
pull(state)
# Create a dataframe
states_switch_df <- data.frame(
switch_1 = states_switch_1,
switch_0 = c(states_switch_0, rep(NA, length(states_switch_1) - length(states_switch_0)))
)
# View the result
print(states_switch_df)
# Create a dataframe
states_switch_df <- data.frame(
switch_1 = states_switch_1,
switch_0 = c(states_switch_0, rep(NA, length(states_switch_1) - length(states_switch_0)))
)
# View the result
print(states_switch_df)
# Get states with switch = 0
states_switch_0 <- Sev5 %>%
filter(switch == 0) %>%
distinct(state) %>%
pull(state)
# View the result
print(states_switch_0)
# How likely is a state to switch, dependent upon their Sev tax rev per person
# Fit a logistic regression model
logistic_model <- glm(switch ~ Sev_cap, data = Sev5, family = binomial)
# Summary of the model
summary(logistic_model)
exp(coef(logistic_model))
#TRY with LOG
# How likely is a state to switch, dependent upon their Sev tax rev per person
# Fit a logistic regression model
logistic_model <- glm(switch ~ Sev_log, data = Sev5, family = binomial)
# How likely is a state to switch, dependent upon their Sev tax rev per person
# Fit a logistic regression model
logistic_model <- glm(switch ~ Sev_cap, data = Sev5, family = binomial)
#TRY with LOG
# How likely is a state to switch, dependent upon their Sev tax rev per person
# Fit a logistic regression model
logistic_model1 <- glm(switch ~ Sev_log, data = Sev5, family = binomial)
# Summary of the model
summary(logistic_model1)
exp(coef(logistic_model1))
#Summary stats by state
summary_stats <- Sev5 %>%
group_by(state) %>%
summarize(
Mean_Sev_log = mean(Sev_log, na.rm = TRUE),
Median_Sev_log = median(Sev_log, na.rm = TRUE),
SD_Sev_log = sd(Sev_log, na.rm = TRUE),
Min_Sev_log = min(Sev_log, na.rm = TRUE),
Max_Sev_log = max(Sev_log, na.rm = TRUE),
N = n()  # Number of observations for each state
)
# Print the summary statistics dataframe
print(summary_stats)
View(summary_stats)
summary_stats_cap <- Sev5 %>%
group_by(state) %>%
summarize(
Mean_Sev_cap = mean(Sev_cap, na.rm = TRUE),
Median_Sev_cap = median(Sev_log, na.rm = TRUE),
SD_Sev_cap = sd(Sev_log, na.rm = TRUE),
Min_Sev_cap = min(Sev_log, na.rm = TRUE),
Max_Sev_cap = max(Sev_log, na.rm = TRUE),
N = n()  # Number of observations for each state
)
# Print the summary statistics dataframe
print(summary_stats_cap)
View(summary_stats_cap)
summary_stats_cap <- Sev5 %>%
group_by(state) %>%
summarize(
Mean_Sev_cap = mean(Sev_cap, na.rm = TRUE),
Median_Sev_cap = median(Sev_cap, na.rm = TRUE),
SD_Sev_cap = sd(Sev_cap, na.rm = TRUE),
Min_Sev_cap = min(Sev_cap, na.rm = TRUE),
Max_Sev_cap = max(Sev_cap, na.rm = TRUE),
N = n()  # Number of observations for each state
)
# Print the summary statistics dataframe
print(summary_stats_cap)
View(summary_stats_cap)
summary_stats
print(n= ...)
print(n=.Last.value)
print(summary_stats, n = Inf)
str(Sev5)
#Will reorder and create Sev6 to get Earliest 18 adopters
Sev6 <- Sev5 %>%
filter(year_effective > 0) %>%  # Filter out rows with year_effective <= 0
arrange(year_effective) %>%
mutate(state_rank = rank(year_effective, ties.method = "first")) %>%
group_by(state) %>%
mutate(early_switch = if_else(min(state_rank) <= 18, 1, 0)) %>%
ungroup()
View(Sev6)
Sev6 <- Sev5 %>%
filter(year_effective > 0) %>%  # Filter out rows with year_effective <= 0
arrange(year_effective) %>%
group_by(state) %>%
mutate(state_rank = rank(year_effective, ties.method = "first")) %>%
mutate(early_switch = if_else(min(state_rank) <= 18, 1, 0)) %>%
ungroup()
View(Sev6)
Sev6 <- Sev5 %>%
filter(year_effective > 0) %>%  # Filter out rows with year_effective <= 0
arrange(year_effective) %>%
distinct(state, .keep_all = TRUE) %>%  # Keep only the first occurrence of each state
mutate(state_rank = row_number()) %>%  # Rank the states by `year_effective`
mutate(early_switch = if_else(state_rank <= 18, 1, 0)) %>%
select(state, early_switch) %>%  # Select only relevant columns for merging
right_join(Sev5, by = "state") %>%  # Merge back with the original data
replace_na(list(early_switch = 0))
View(Sev6)
Sev6 <- Sev5 %>%
filter(year_effective > 0) %>%  # Filter out rows with year_effective <= 0
arrange(year_effective) %>%
mutate(state_rank = rank(year_effective, ties.method = "first")) %>%
group_by(state) %>%
mutate(early_switch = if_else(min(state_rank) <= 18, 1, 0)) %>%
ungroup()
#Will reorder and create Sev6 to get Earliest 18 adopters
Sev6 <- Sev5 %>%
filter(year_effective > 0) %>%  # Filter out rows with year_effective <= 0
arrange(year_effective) %>%
mutate(state_rank = rank(year_effective, ties.method = "first")) %>%
group_by(state) %>%
mutate(early_switch = if_else(min(state_rank) <= 1121, 1, 0)) %>%
ungroup()
View(Sev5)
#Early adopters logit
logistic_model_early <- glm(early_switch ~ Sev_log, data = Sev6, family = binomial)
# Summary of the model
summary(logistic_model_early)
exp(coef(logistic_model_early))
write.csv(Sev6,"Sev_early_switch.csv")
